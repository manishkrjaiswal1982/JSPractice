<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
    <title>Document</title>
    <script type ="module" defer="true" src="./scriptImport.js"></script> 
    <style>
        .custom-list li::marker { 
            
            color: #00FF00 !important;
            color: var(--bullet-color, blue) !important;            
        }
    </style>

    <script>
        let arr1 = [12,223,33,4,5,33,6,5,12];
        let arr2 = [], arr3 = [];
        const currentDate = new Date();
        const pattern = /[0-9]+/;
        const squareRoot = Math.sqrt(25);

        let arr5 = [10,12,16,28,450,250,90,70,20,34]
        let arr50 = [10,59,90,55,61,54]
        let arr51 = [55,61,90,10,59,54]
        
        let arr8 = [10, 20, "ev"];
        console.log("arr8: " +arr8);
        arr8.fill("staticValue");
        console.log("arr8 updated value after fill function is: " +arr8);

        //const variable can also be changed through indexing of array
        const arr11 = [22, 33];
        arr11[0] = "gg";

        console.log(arr11);
              
        let a1 = arr5.every(function(num){
            if (num > 70) { return num}
        })
        console.log("a1 value iss: " + a1)

        let aSum = arr5.every(function(num){
            if (num%2 === 0) { return num}
        })
        console.log("aSum value is: " + aSum)

        let checkOdd = function(val, index, arr){
            if(arr[index]%2 != 0) { return val}
        }

        let aOdd = arr50.every(checkOdd)
        console.log("aOdd: " +aOdd)

        // Check if two array are similar
        let checkArrayEqual = (arr1,arr2) => {
            let tempArr = [];
            arr1.forEach(function(value,index,array){
                tempArr.push(arr2.includes(value)); 
            })
            let valEqual =  tempArr.every(function(val,index,arr){
                if (arr[index] == true){ return val};
            })
            return valEqual;
          }

        console.log("if array is equal:" +checkArrayEqual(arr50,arr51));

        // Check if two array are similar End
        
          let a2 = Array.from("12222333q34243AmanUMAr");
          console.log("Type of a2" +Object.prototype.toString.call(a2) + " Value is:" +a2);
          console.log(a2.length)

          let set5 = new Set(a2);
          console.log("set5 value is" +set5)
          a2 = [...set5];
          console.log("a2 value is" +a2);
          console.log(Object.prototype.toString.call(a2));

          let arr9 = [];
          arr9 = arr5.map(function(val){
            return val*10 
          });

          console.log("arr9 value is:" +arr9)

        //   Map function through arrow function
        arr9 = arr5.map(val => val*val)
        console.log("Updated arr9 value in squre format:" +arr9)

        arr9 = arr5.map((val,index,arr) => arr[index]*arr[index]*arr[index])
        console.log("Updated arr9 value in cube format:" +arr9)

        let add = () => {
            return 15;
        }

        let set4 = new Set(arr1);
        let arr4 = [...set4]
        console.log("arr4 value is:" + arr4);
        
        // console different functions
        console.table(arr4);
        console.error("This is error msg generated through <code>");
        console.warn("This is warning msg generated through <code>");


        arr4.sort((a,b) => b-a); //Descending order
        console.log("arr4 value after sorting is:" + arr4);

        // multiply each array value from 10
        arr1.forEach((item,index) => { arr1[index]  = item*10; })
        console.log(arr1);

        arr3 = arr1.filter((item,index) => {
            return item >= 100
        })
        
        let is_array = (arr) => {
            if (Object.prototype.toString.call(arr) === "[object Array]"){
                return true;
            }
            else{
                return false;
            }
        }

        console.log(Object.prototype.toString.call(arr3));
        console.log("Array3 value:" +arr3)
        arr2 = new Set(arr1);
        console.log(arr2);
        console.log(Object.prototype.toString.call(arr2));
        console.log(Object.prototype.toString.call(arr1));
        console.log(Object.prototype.toString.call(squareRoot));
        console.log(is_array(arr1));

        // Hoisting
        /* In JavaScript, Hoisting is the default behavior of moving all the declarations at the top of the scope before code execution.
        It allows us to call functions before even writing code.
        Note: JavaScript only hoists declarations, not initializations. Hoisting example below.
        Note: Hosting with let and const are different than var.
        */

        console.log("a value through hoisting is: " +a);
        hoisting();
        // console.log(b);
        // hoisting_FE();
        
        var a = 5;
        let hoisting_FE = function(){
            console.log("function expression");
        }

        function hoisting(){
            console.log("Simple function");
        }

        let b = 5;

        // When you use setTimeout with a delay of 0 milliseconds, it doesn't mean that the
        // function will execute immediately; rather, it means the function will be 
        // scheduled to run as soon as the JavaScript event loop becomes idle.
        console.log("Start");

        setTimeout(function() {
        console.log("Inside setTimeout");
        }, 0);

        console.log("End");
       
        // JS is single threaded, non-blocking or asynchronus concurrent language means code will be executed line by line.
        // It has call stack, web API, callback queue, an event loop.
        /*
        Call Stack - call stack is a data structure, where the code is currently executing. i.e When a function is called, it's pushed onto the call stack. When a function returns, it's removed from the stack.
        Web API - Web APIs are provided by the browser's environment. i.e it allows JavaScript to interact with external resources, such as making HTTP requests, handling timers etc. When you use a function like setTimeout or make an AJAX request, the actual work is done by the Web API, not the JavaScript engine.
        Callback Queue - The callback queue is a data structure that that holds callback functions.
        Event Loop - If the call stack is empty, and there are functions in the callback queue, the event loop will move a callback function from the queue to the call stack for execution. This process allows JavaScript to handle asynchronous operations without blocking the main thread.
        Example below for Event loop and above all concept
        */
        console.log("Start");

        setTimeout(function () { //  schedules a callback to run after 1000 milliseconds. The actual timing is managed by the Web API.
        console.log("Timeout callback");
        }, 1000);

        fetch("https://fakestoreapi.com/carts") //asynchronous HTTP request and registers callbacks to handle the response. Handled by Web API.
        .then(function (response) {
            return response.json();
        })
        .then(function (data) {
            console.log("Data from API:", data);
        });

        console.log("End.........");
        
        // Temporal Dead Zone
        console.log(x1); // ReferenceError: Cannot access 'x' before initialization
        let x1 = 10;
        
        /*
        A temporal dead zone (TDZ) is the block where a variable is inaccessible until the moment the computer initializes it with a value. 
        The Temporal Dead Zone is a concept related to the use of variables declared with the let and const keywords.
        let and const have 2 differences than var
        1. They are blocked scope.
        2. Accessing the var before initialized throw undefined error, while accessing let and const throw "reference error".   
        */
        
        // Microtask Queue - A Microtask queue is a queue of tasks that are executed after the current task. The microtask queue is handled by the JavaScript engine before it moves on to the next task in the callback queue.
        /* Microtask queue is handled by the JavaScript engine before it moves on to the
           next task in the callback queue. The Callback queue is handled by the 
           JavaScript engine after it has executed all tasks in the microtask queue.*/
        console.log('start Microtask');
 
        setTimeout(function() {
            console.log('setTimeout Microtask');
        }, 0);
    
        Promise.resolve().then(function() {
            console.log('promise resolve Microtask');
        });
    
        console.log('end Microtask');

      

        /*
        In the example above, the ‘setTimeout’ callback is added to the callback queue while promise's callback in the micro queue.
        The output of the above code
        start
        end
        promise resolve
        setTimeout
        */

        // Benefit of External script file -  may gets cached or orgnizing code.
        /* Render blocking - when html parsing is blocked due to execution of script file.
        It may block the html parsing if inline script, external file script in head tag
        without 'async' or 'defer' attribute.

        To mitigate render-blocking issues and improve page load performance, you can 
        employ the following techniques below:

        1. Asynchronous Loading: Use the async or defer attribute with the script tag to load 
           JavaScript files asynchronously.            

        2. Move Scripts to the Bottom: Place script tags just before the closing body tag.
        3. Lazy Loading: Lazy-loading defers the loading and execution of JavaScript until it's 
            required, improving the initial page load time.

        By addressing render-blocking issues, you can ensure that your web pages load 
        faster, provide a better user experience, and improve search engine optimization
        (SEO) rankings, as faster-loading pages are favored by search engines.
        */

        /*
        These 2 are not limited to javascript only. These technique can be used in any lang.
        Throttling - Throttling or sometimes also called throttle function is used to call a function after 
        every millisecond or a particular interval of time only the first click is executed immediately.
        As example if we call any function on rapid events like scrolling, resizing, typing, or mouse movements 
        window scroll, the function will be called multiple time which is not desired, hence we can control it 
        through limiting a particular interval of time only.
        
        Debouncing - The purpose of debouncing is to ensure that a function is only executed 
        after a certain period of inactivity, rather than being triggered immediately on every event.
        */        
        
    </script>
</head>
<body onresize="resizeWindow();">
    <br/><br/><a href = "javascript:void(0);">It will do nothing.</a> 
    <!-- void(0) or void 0  - tells the browser to "do nothing" i.e., prevents the browser from reloading or refreshing the page -->
    <div class="array1" id="mainArray"></div>
    <ul class="name">
        <li>M</li>
        <li>A</li>
        <li>N</li>
        <li>I</li>
        <li>S</li>
        <li>H</li>
    </ul>

    <div class="topicTostudy"></div>
    <button id="btn6" type="button" onclick="fn99();">Non-Throttle</button>
    <button id="btn7" type="button">Throttle</button>
    <div class="contentA" onmousedown= "mouseButtonDetect(event)" style="font-size: 40px;width:400px;height:400px;border:10px #000 solid;overflow:scroll;">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eligendi quae omnis, quaerat voluptas sit placeat atque aut numquam nihil! Perspiciatis necessitatibus ut nobis dignissimos commodi quos veniam, corrupti suscipit libero laborum dolores ullam doloremque quis iste atque sint consequuntur id cupiditate ipsum, eveniet nostrum voluptates. Quos exercitationem nisi, voluptates quidem sit sequi quibusdam voluptatem delectus autem ipsum quaerat reiciendis dolorum odio iure magnam possimus voluptatibus vero aut dolorem nulla, cum, sint inventore perspiciatis. Aut, debitis voluptates. Ratione, cumque enim necessitatibus quis perspiciatis dolorem in deleniti architecto voluptates a vitae earum? Odit ea neque ipsam voluptatum porro fuga officia adipisci explicabo sunt, qui et quaerat, dolorem natus. Earum nostrum est fugit aspernatur quis quas, recusandae dolorum voluptas vitae voluptate repellat accusamus explicabo blanditiis et deleniti exercitationem maiores! Fugiat ratione mollitia ea est. Est voluptates nihil nostrum ad, fugit voluptatum distinctio corrupti numquam dignissimos dolores, labore cum beatae cumque provident. Nam sunt modi corporis eius ipsa similique magni explicabo excepturi provident! Delectus, provident cumque mollitia ea praesentium officiis veniam nemo eum incidunt cum ut facilis distinctio maxime reprehenderit vero, atque voluptatum, veritatis impedit adipisci. Aspernatur officiis ipsa beatae aliquam, placeat enim optio doloribus debitis esse eaque cupiditate? Enim possimus deleniti velit eligendi!</div>
    <button id="btn1" type="button">Button.....1</button>
    <button id="btn2" type="button" onclick="getTopic();">Click here to know about study materials.</button>
    <button id="btn3" type="button" onClick="fcbAdd(3,4,fcb1)">Callback function1</button>
    <button id="btn4" type="button" onClick="fcbAdd(30,40,fcb2)">Callback function2</button>
    <button id="btn5" type="button" onClick="fcbAdd(30,40,function(){console.log('Anynomous fn')})">Callback function3</button>

    <h2>Window Object</h2>
    <button class="fancy-button" onclick="openWin()">Open window </button>&nbsp;&nbsp;<button class="fancy-button" onclick="closeWin()">Close window </button>
    <button class="fancy-button" onclick="resizeWin()">Resize window </button>

    <h2>Location Object</h2>
    <button class="fancy-button" onclick="locReload()">Reload Method </button>
    <button class="fancy-button" onclick="locAssign()">Assign Method</button>
    <button class="fancy-button" onclick="locReplace()">Replace Method</button>


    <br><br><div class="label1">Input the texts.</div>
    <input type="text" id="textBox1" placeholder="Type some texts" onkeydown="detectKey(event)">
    <ul class="custom-list">Custom List
        <li>Item 1</li>
        <li>Item 2</li>
        <li>Item 3</li>
    </ul>
    <div class="bankDiv"></div>
    <div id="ModuleDiv"></div>
    <div id="productFromJSON"></div>
    <div id="TextFromTxt"></div>
    <div id="productFromJSONFetchM"></div> 
          
</body>
<script>
    let obj1 = document.querySelector(".name").getElementsByTagName("li");
    console.log("HH: " +obj1)
    console.log(Object.prototype.toString.call(obj1));
    console.log(obj1.length);
    console.log(document.all)

    console.log("getAttribute property:" +document.querySelector(".array1").getAttribute("id"))

    // To make the comment
    var newComment = document.createComment("This is comment through dynamic Javascript");
    console.log(newComment);
    console.log("this is:" +this);

    // Through JQuery
    $(".name").find("li").each(function(index,item){
        console.log($(this).text());
    })

    // Through Java script
    document.querySelector("#btn1").addEventListener("click", function(){
        console.log(this.innerHTML);
    });

    // Function expression "f1" defines function name but not the variable
    let f1 = function(a,b){
    return Math.floor(a+b);
    }

    //Arrow function
    let f2 = (a,b) =>{
        return Math.floor(a-b);        
    }

    let sum = f1(10,23);
    console.log("Sum:" +sum);

    let sub = f2(33,23);
    console.log("Sub:" +sub);

    // "continue" keyword use, "break" keywords exit the loop
    for (let i=0; i<=5; i++){
        if (i==2){
            continue;           
        }
        console.log("i value through continue keyword is:" +i);
    }

    // Exit through "return" keyword from a function
    let print = () => {
        for (let i=0; i<=5; i++){
        if (i==2){
            return;           
        }
        console.log("j value is:" +i);
        } 
    }
    print();

    let de = document.documentElement
    console.log("de: " +de.lang)
    de.style.color = "red";
//  document.title = "Allterree"
    document.activeElement
    console.log(document.domain);

let arrTopic = ["createTextNode_fn","replaceChild_fn", "cloneNode_fn", "contains_fn", "hasChildNodes", "hasAttribute"];
let getTopic = () => {
    document.querySelector(".topicTostudy").innerHTML = '<span id="topicContainer"><ul>' +
       arrTopic.map(val => '<li style="font-size:20px">' +val + '</li>') +
    '</ul></span>';
}
   
    console.log("Does it contains:" +document.body.contains(document.getElementById("btn3")));
    console.log("hasAttribute: " +document.querySelector("#mainArray").hasAttribute("class"));
    console.log("hasChildNode:" +document.querySelector(".topicTostudy").hasChildNodes());

    // window resize
    let resizeWindow = () => {
        console.log("Inner Width:" +window.innerWidth);
        console.log("Inner Height:" +window.innerHeight);
        console.log("Outer Width:" +window.outerWidth);
        console.log("Outer Height:" +window.outerHeight);
    }

    // To open and close window
    var myWin;
    let openWin = () => {
        myWin = window.open("", "_blank", "width:500px;height:500px");
        myWin.document.write("Hello");
        myWin.moveTo(400,300);
        myWin.moveBy(400,300);
    }

    let closeWin = () => {
        myWin.close();
    }

    let resizeWin = () => {
        window.resizeTo(200,200);
        // window.resizeBy(200,200); "By" Works on relative position
    }

    // window.scrollTo(0,20) to scroll to bottom ("To" works on absolute position)
    // window.scrollTo(0,-20) to scroll to top ("To" works on absolute position)
    // window.scrollTo(20,0) to scroll to right ("To" works on absolute position)
    // window.scrollTo(-20,0) to scroll to left ("To" works on absolute position)

    // location object properties
    console.log(location)
    console.log(location.hostname)
    console.log(location.pathname)
    console.log(location.href)

    // location object methods
    let locReload = () => {
        location.reload(); //It reloads the page.
    }

    let locAssign = () => {
        location.assign("https://translate.google.com/"); //It sets the url to the location bar and history button works here.
    }

    let locReplace = () => {
        location.replace("https://translate.google.com/"); //It is just like assign function but It deletes the history it means user can't use browser back buttons.
    }

    console.log(history) //
    // history.go(1) or history.go(-1) to move next one or back one in the browser history

    // Window object 2 properties
    window.addEventListener('scroll', function() {
        console.log("How much Window - X axis scrolled:" +window.pageXOffset);
        console.log("How much Window - Y axis scrolled:" +window.pageYOffset);
    });

    let targetDiv = document.querySelector(".contentA");
    // console.log("How much Y axis scrolled screenTop:" +targetDiv.scrollTop);
    console.log("How much X axis scrolled through scrollLeft:" +targetDiv.scrollLeft);

    // Mouse event co-ordinate
    document.querySelector(".contentA").addEventListener("mousemove", function(event){
        console.clear();
        console.log("Client Y / Client X :" +event.clientX + ":" +event.clientY)
        console.log("Client Y / Client X :" +event.x + ":" +event.y) //ClientX / ClientY is also indicated by x and y only
        console.log("Screen Y / Screen X :" +event.screenX + ":" +event.screenY) //From screen top and left
        console.log("Offset Y / Offset X :" +event.offsetX + ":" +event.offsetY) //From element left and top
        console.log("Page Y / Page X :" +event.pageX + ":" +event.pageY) //pageX and pageY properties are actually related to the whole document page, not the viewport.
    })

    document.querySelector(".contentA").addEventListener("scroll",() => {
        console.clear();
        console.log("How much Y axis scrolled screenTop:" +targetDiv.scrollTop);
        console.log("ScrollHeight and ScrollWidth:"  +targetDiv.scrollHeight + " " +targetDiv.scrollWidth);
        
        console.log("OffsetHeight and OffsetWidth:"  +targetDiv.offsetHeight + " " +targetDiv.offsetWidth);
        // offsetWidth and offsetHeight return the width and height of an element in pixels including padding,border and scrollbar.
        
        console.log("ClientHeight and ClientWidth:"  +targetDiv.clientHeight + " " +targetDiv.clientWidth);
       // clientWidth and clientHeight return the width and height of an element in pixels but not padding,border, margin and scrollbar.
             
    });
// Detect copy/paste/cut events
// Dont add keyword "on" with event on addEventListner. While it is mandatory with inline event like onCopy() etc.
    document.querySelector(".contentA").addEventListener("copy",() =>{
        // console.clear();
        console.log("you Copied the texts.")
    });

    document.querySelector("#textBox1").addEventListener("cut",() =>{
        // console.clear();
        console.log("you cut the texts.")
    });

    document.querySelector("#textBox1").addEventListener("paste",() =>{
        // console.clear();
        console.log("you paste the texts.")
    });

    // console.assert(expression, object). The console.assert() method is used in programming to assert that a given condition is true. If the condition is false, an error message is logged to the console along with a stack trace.
    const x = 6;
    const y = 5;
    const reason = 'x is expected to be less than y';
    console.assert(x < y, {x, y, reason});

    // Keys detection
    let detectKey = function(e) {
    // console.log("key pressed");
    let ke;

    switch (true) {
        case e.metaKey:
            ke = "Meta Key";
            break;
        case e.ctrlKey:
            ke = "Control Key";
            break;
        case e.shiftKey:
            ke = "Shift Key";
            break;
        case e.altKey:
            ke = "Alt Key";
            break;
        default:
            ke = "Other Key";
    }

    // console.warn(ke);
    console.log("Key pressed:" +e.key) //"key" property is used with only keyboard's "keydown" event
    }; 

    let mouseButtonDetect = function (e){
        let buttonM = e.button; //Return "0" for left button, "1" for middle button and "2" for right button
        console.clear();
        console.log("You pressed button:" +buttonM);
    }

    // Detect online/offline of the user
    if(navigator.onLine) { console.log("You are online as of now."); }
    else { console.log("You are offline as of now."); }

    window.addEventListener("online",function(){
        console.log("AddeventListner: you are online.")
    });

    window.addEventListener("offline",function(){
        console.log("AddeventListner: you are offline.")
    });
    
    // Type of functions
    // Immediately Invoked Function Expression (IIFE)
    // Generator Function
    // Callback Function
    // Higher-Order Function

    // Higher-order functions in JavaScript are functions that operate on other functions, either by taking them as arguments, returning them as values, or both. 
    // The map function applies a given function to each element of an array and returns a new array with the results.
    const numbers = [1, 2, 3, 4, 5];
    const squared = numbers.map((num) => num * num);
    // Example of High-order functions are filter, reduce, forEach, sort, some and every etc.

    // Generator functions return a generator object. Generator objects are used either by calling the next method on the generator object
    // Generate Function generates three different numbers in three calls
    function* fun() {
        yield 10;
        yield 20;
        yield 30;
    }
    
    // Calling the Generate Function
    let gen = fun();
    console.log(gen.next().value);
    console.log(gen.next().value);
    console.log(gen.next().value);
    // Generate Function End 

    // Start - Immediately Invoked Function Expression is are functions that are executed when they are initialized.
    (function(){
        console.log("Immediately imvoked functions expression.........")
    })();
    // End - Immediately Imvoked Function Expression

    // start - callback function
    let fcb1 = () => {
        console.log("Callback function 1:\n")
    }

    let fcb2 = () => {
        console.log("Callback function 2:\n")
    }

    let fcbAdd = (n1,n2,callback) => {
        console.log("Addition through callBack function:" +n1+n2);
        callback();
    }
    // End - callback function
    // console.log("Arguments length:" +arguments.length)

    // Closure
    // Lexical Scope
    // A closure is a function having access to parent scope. It preserve the data from outside. or in other defination, a closure is a inner function that has access to the outer function's variables.
    // A closure is a function having access to the parent scope, even after the parent function has closed.
    // For every closure we have three scopes: Local scope, Outer scope and Global scope. Example below:
    Gvar1 = "Global variable";
    let outerfn1 = () => {
        let Ovar1 = "Outer function variable";
        document.write("<br>" + Ovar1 + "<br>");
        let innerfn1 = () => {
            let Ivar1 = "Inner function variable";
            document.write("<br>" + Ivar1 +"<br>");
            document.write("<br>" + Ovar1 + "<br>");
            document.write("<br>" + Gvar1 + "<br>");
        }
        innerfn1();
    }
    outerfn1();
    
    const list = document.querySelector('.custom-list');
    // Function to change the color
    function changeBulletColor(colora) {    
        list.style.setProperty('--bullet-color', colora);
    }
    changeBulletColor("#FFF000");

    // CORS (Cross Origin Resource Sharing) - Issue happens when requests are sent from domain/origin "A" to domain/oririn "B".
    /* Browser sends pre-flight request to server. Browser send the request in form of header having information 
        => request methods like GET/POST/Update/Delete etc
        => user agent/hostname
        => Domain / status / protocol
        => HTTP body
        => Cookies (Intially set by server to browser to detect if re-request made)
        => Access control Allow origin - should be either * or requested domain to avoid such error
    */

    // Call / Apply / Bind Methods are called the Function Borrowing too.
    let object1 = {
        name: "Manish Kumar",
        Designation: "Senior Technical Developer"
    }

    let object2 = {
        name: "Manoj Kumar",
        Designation: "Elearning Developer"
    }

    let printObjectDetails = function(city, qual){
        console.warn(this.name + " " + city + " " + qual);
    }

    printObjectDetails.call(object1, "Delhi","MCA");
    printObjectDetails.call(object2, "Bihar", "MA");
    printObjectDetails.apply(object2, ["MP", "BA"]); //Pass an array instead of multiple arguments
    
    let b1 = printObjectDetails.bind(object1, "Punjab","Phd.");
    b1();

    /* Error Type
    403 - Forbidden error from server
    404 - Page Not Found
    500 - Internal Server Error
    502/504 - Bad Gateway / Gateway Timeout
    */

   /* Chrome Developer Tool
   Coverage / Request Blocking / monitor / MonitorEvents / debug directly from console / copy
   ?_ / 
   */

  let arr98 = [11,22,33,44,55,44,33,22,11,0];
  let arr97 = arr98.slice(6); //Slice update in new array and extract part of the array.
  console.log("Slice example:" +arr97);
  arr98.splice(2, 1, 2, 320); //Splice don't update in new array but work on existing array. It just work as push/pop but in mid of the array.
  console.log("Splice example:" +arr98);

  //Asynchronous Javascript
let BankName = ["SBI", "PNB", "HDFC", "ICICI"];

let getRecord = () => {
    setTimeout(() => {
        document.querySelector(".bankDiv").innerHTML = "<ul>" +
        BankName.map(val => {
        return `<li>${val}</li>`; 
        }).join('') + 
        "</ul>";
    }, 1000);  
}

let addRecord = () => {
    return new Promise ((resolve,reject) => {
        setTimeout(() => {
        BankName.splice(1,0, "Canara", "Kotak");
        resolve();
        // let error = false;
        // if(!error){
        //     resolve();
        // }else{
        //     reject("kuch locha hai");
        // }
    }, 2000); 
    });
      
}
// getRecord();
let start = async () => {    
    await addRecord();
    getRecord();    
}
start();

// Cookie: To store small ammount of data in browser. The cookies limit upto 4KB size and number of cookie are upto 20. 
// Cookies are sent to server through http header in each request.
// alert(`initial cookie shown: ${document.cookie}`);

// let mykey = prompt("Enter you key");
// let myvalue = prompt("Enter the value");
// document.cookie = `${encodeURIComponent(mykey)}=${encodeURIComponent(myvalue)}`;
// localStorage.setItem(mykey,myvalue); // local storage
for (let i=0; i<=localStorage.length; i++){
    if (localStorage.key(i) == "hjhjh") {
    console.log(`removed key ${localStorage.key(i)}`)
    localStorage.removeItem(localStorage.key(i));
    }
}
//Local storage: to store the data from particular domain. Local storage are not sent to server like cookie. 
// This data doesn't loose even page or browser refresh. (page or browser closing/restarting)
// localStorage.clear(); //Clear local storage completely
// localStorage.length; //Find local storage length
// localStorage.key(0); //Find local storage key value at index set

// console.log(`The value at local storage at key ${localStorage.getItem(mykey)} is: ${localStorage.getItem(myvalue)}`)
// alert(`Updated cookie shown: ${decodeURIComponent(document.cookie)}`);

//Session storage - the data is not accessible from another tab of same browser. Data survive on page refersh but not opening/closing the tab.
sessionStorage.setItem("1st session key","1st session value");
console.log("The session value is: " + sessionStorage.getItem('1st session key'));

//Storage event fires when localstorage value gets changed.
window.onstorage = (e) =>{
    alert(`local storage value changed....`);
}

let fn99 = () => {
    console.log("Button Throttle clicked...");
};

// Start - Object Prototype - The JavaScript prototype property allows you to add new properties to object constructors.
function Person(first, last, age, eyecolor) { //example of constructor function
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eyecolor;
}
const myFather = new Person("A","Kumar",67, "white");
const myMother = new Person("N","Devi",63, "normal");
console.log(myFather);
console.log(myMother);
myMother.profession = "Housewife"; // Added instance member, and used on object directly.
console.log(myFather);
console.log(myMother);
// classname.prototype.key = ""; //Syntax for adding prototype member, only added on class directly
Person.prototype.profession = "Job";
console.log(myFather.profession);
console.log(myMother.profession);
// End

// Javascript object has special property called prototype that is either null or references another objects.
let a11 = {
    name: "MK"
};

let p = {
    fun: () => {
        console.log("--------fun is called---------")
    }
};

a11.__proto__ = p;
a11.fun();

// Block scoping, also known as lexical scoping, is a feature in JavaScript that defines 
// the scope or visibility of variables and functions within a specific block of code
// Block scoping was introduced in ECMAScript 6 (ES6) through the let and const declarations, 
// providing an alternative to the function-level scope of variables declared with var.

function example() {
  if (true) {
    let x = 10; // Block-scoped variable
  }
  console.log(x); // Error: x is not defined
}

function example() {
  if (true) {
    var y = 20; // Function-scoped variable
  }
  console.log(y); // 20, y is accessible here
}

// Start - Destructuring Array and Destructuring object
let user = ["MK", "Delhi", 40, "MCA"];
let [name, city, age, course] = user;
console.log(name + " " + city + " " + age + " " +course);

let user1 = {
    name1: "MKJ",
    id1: "#F0001"
}

let {name1, id1} = user1;
console.log(name1 + " " + id1);
// End

// Start - Rest operator
let sumR = function (nameR, ...args){ //Rest operator is used when function to be declared
    let tempSum = 0;
    for (let i in args){
        tempSum += args[i];
    }
    document.write (`${nameR} got score: ${tempSum}`);   
}
sumR("Jaiswal jee", 77,11,22);
let arr102 = [77,10,22]
sumR("<br>Manish jee - Spread Operator", ...arr102); //Spread operator is used when function is being called to spread the array items
// End - Rest operator

// Strict Mode on
"use strict";
a101 = 101;
console.log("The value of var a101 is: " +a101);

// x += y is equivalent to x = x + y

// DOM append method like 
// appendChild, insertBefore, insertAdjecentElement, insertAdjecentHTML and insertAdjecentText

// Only appends doesn't create
// appendChild - whereToAdd.appendChild(whatToadd); Add always in last
// insertBefore - whereToAdd.insertBefore(whatToadd, afterWhichToAdd);

// Create and appends both - insertAdjecentElement, insertAdjecentHTML and insertAdjecentText


</script>
</html>